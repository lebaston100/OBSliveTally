<!doctype html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>OBS Tally</title>
<script src="https://cdn.jsdelivr.net/npm/obs-websocket-js@5.0/dist/obs-ws.global.min.js"></script>
<!-- <script src="obs-ws.min.js"></script> -->

<script>
	var obsSettings = {
		host: "127.0.0.1:4455",      // set obs ip/port here
		password: "YourPasswordHERE"  // set obs password here
	}

	const screenShotInterval = 4000;
	const screenShotSize = 300;

//------------------------------------------------------------------------------------------------------------------------
	// Internal variables, do not change anything here unless you know what you are doing
	// OBS related
	const obs = new OBSWebSocket();
	var reconnectInt = null;
	var connectionIsOpen = false;
	var iCanHazLocalStorage = typeof(localStorage)  == "undefined" ? false : true;
	var obsDefaultSettings = structuredClone(obsSettings);

	// DOm objects
	var DOobsHost = null;
	var DOobsPw = null;
	var DOsettingsBox = null;
	var DOselectionBox = null;
	var DOselectedTitleBox = null;
	var DOselectedTitleText = null;
	var DOsrStatusBox = null;
	var DOsrStatusText = null;
	var DOcMenableAutoConnect = null;
	var DOcMenableAutoRestore = null;
	var DOcMenableScreenshot = null;
	var DOscreenshotBox = null;
	var DOscreenshotImg = null;

	// Screenshot stuff
	var screenShotIntervalId = null;

	// State stuff
	let currentState = new Proxy({
		"watching": null,          // Can be null=none, "StreamState", "RecordingState", "Scene", "Input"
		"studioModeEnabled": null, // If studio mode in obs is enabled
		"RecActive": false,        // Recording Status
		"StreamActive": false,     // Streaming Status
		"prvScn": "",              // Current preview scene
		"pgmScns": [],             // Current program Scene (can be 2 while transitioning)
		"wtchInput": "",           // Name of Input if we watching one
		"wtchScenes": []           // Names of the Scenes we are watching (1= for Scene, >=1 for Input but generated by us)
	}, {
		set(obj, prop, newval) {
			// Override set handler to get change events
			// Only update if value is different (we'll see if it works like that)
			if (obj[prop] !== newval) {
				//console.log(`Changed currentState.${prop} to ${newval}`);
				obj[prop] = newval;

				if (prop == "StreamActive") {
					onStreamStatusChanged(newval);
				} else if (prop == "RecActive") {
					onRecordingStatusChanged(newval);
				} else if ((prop == "prvScn" || prop == "pgmScns") && (obj.watching == "Scene" || obj.watching == "Input")) {
					updateSceneOrInputFrontend();
				} else if (prop == "watching" && newval && !screenShotIntervalId) {
					// If screenshot is enabled, start it
					if (localStorage.getItem("screenshot.enable") == "Yes") startScreenshots();
				}
				return true;
			}
			return false;
		}
	});

	window.addEventListener("DOMContentLoaded", init);
	async function init() {
		// Gather DOM elements
		DOobsHost = document.getElementById("obsHost");
		DOobsPw = document.getElementById("obsPw");
		DOsettingsBox = document.getElementById("settingsBox");
		DOselectionBox = document.getElementById("selectionBox");
		DOselectedTitleBox = document.getElementById("selectedTitleBox");
		DOselectedTitleText = document.getElementById("selectedTitleText");
		DOsrStatusBox = document.getElementById("srStatusBox");
		DOsrStatusText = document.getElementById("srStatusText");
		DOcMenableAutoConnect = document.getElementById("cMenableAutoConnect");
		DOcMenableAutoRestore = document.getElementById("cMenableAutoRestore");
		DOcMenableScreenshot = document.getElementById("cMenableScreenshot");
		DOscreenshotBox = document.getElementById("screenshotBox");
		DOscreenshotImg = document.getElementById("screenshotImg");

		// Update obs connection settings from localstorage if available
		if (iCanHazLocalStorage) await readLocalStorageConnectionSettings();

		// Update frontend fields with values
		setValue(DOobsHost, obsSettings.host);
		setValue(DOobsPw, obsSettings.password);

		// Initialize custom context menu
		await prepareContextMenu();

		// If user whished to, automatically try to connect
		if (iCanHazLocalStorage && localStorage.getItem("connect.auto") == "Yes")  {
			DOcMenableAutoConnect.innerText = "Disable auto connect";
			await attemptObsConnection();
		}

		// Update auto restore text
		if (iCanHazLocalStorage && localStorage.getItem("connect.restore") == "Yes")  DOcMenableAutoRestore.innerText = "Disable auto restore";

		// Update screenshot text
		if (iCanHazLocalStorage && localStorage.getItem("screenshot.enable") == "Yes")  DOcMenableScreenshot.innerText = "Disable PGM screenshot";
	}

	// Try to connect to obs
	async function attemptObsConnection() {
		// Make sure to cancel any reconnect timer
		if (reconnectInt) clearInterval(reconnectInt);
		reconnectInt = null;

		// Get host and pw from input fields
		obsSettings.host = DOobsHost.value;
		obsSettings.password = DOobsPw.value;

		// The connect
		try {
			const {
				obsWebSocketVersion,
				negotiatedRpcVersion
			} = await obs.connect(`ws://${obsSettings.host}`, obsSettings.password, {rpcVersion: 1});
			console.log(`Connected to obs-websocket ${obsWebSocketVersion} (using RPC ${negotiatedRpcVersion})`);
		} catch (error) {
			console.error("Failed to connect", error.code, error.message);
		}
	}

	// obs-websocket connection was closed for whatever reason
	obs.on("ConnectionClosed", () => {
		console.log("Connection to obs-websocket was closed");
		connectionIsOpen = false;
		if (!reconnectInt) reconnectInt = setInterval(attemptObsConnection, 2000);
		// Maybe show somewhere that the connection was disconnected and status might not beaccurate
	});

	// Identified is the new open
	obs.on("Identified", async () => {
			clearInterval(reconnectInt);
			connectionIsOpen = true;
			reconnectInt = null;

			// Save the current obs connection settings to localStorage
			if (iCanHazLocalStorage) await saveLocalStorageConnectionSettings();

			// If not already done generate selection boxes
			if (!currentState.watching) await getWatchSelectionItems();

			// Hide connection settings box
			DOsettingsBox.style.display = "none";

			// Get initial states
			await getInitialObsStates();

			// If session restore is enabled, try it
			if (localStorage.getItem("connect.restore") == "Yes") restoreWatchStatus();
	});

	// obs event StreamStateChanged
	obs.on("StreamStateChanged", async (event) => {
		let { outputState } = event;
		if (outputState == "OBS_WEBSOCKET_OUTPUT_STOPPED") {
			currentState.StreamActive = false;
		} else {
			currentState.StreamActive = true;
		}
	});

	// obs event RecordStateChanged
	obs.on("RecordStateChanged", async (event) => {
		let { outputState } = event;
		if (outputState == "OBS_WEBSOCKET_OUTPUT_STOPPED") {
			currentState.RecActive = false;
		} else {
			currentState.RecActive = true;
		}
	});

	// obs event StreamStateChanged
	obs.on("CurrentProgramSceneChanged", async (event) => {
		currentState.pgmScns = [event.sceneName];
	});

	// obs event CurrentPreviewSceneChanged
	obs.on("CurrentPreviewSceneChanged", async (event) => {
		currentState.prvScn = event.sceneName
	});

	// obs event SceneTransitionStarted
	obs.on("SceneTransitionStarted", async (event) => {
		currentState.pgmScns.push(currentState.prvScn);
		updateSceneOrInputFrontend();
	});

	// obs event StudioModeStateChanged
		obs.on("StudioModeStateChanged", async (event) => {
		currentState.studioModeEnabled = event.studioModeEnabled;
		updateSceneOrInputFrontend();
	});


	// obs event SceneRemoved
	obs.on("SceneRemoved", async (event) => {
		const { sceneName } = event;
		// if we are watching that scene for any reason
		if (currentState.wtchScenes.includes(sceneName)) {
			let posInList = currentState.wtchScenes.indexOf(sceneName);
			currentState.wtchScenes.splice(posInList, 1); // remove from watchlist
			updateSceneOrInputFrontend();
			if (currentState.watching == "Scene" && posInList == 0) await getWatchSelectionItems();
		}
	});

	// obs event SceneNameChanged
	obs.on("SceneNameChanged", async (event) => {
		const { oldSceneName, sceneName } = event;
		// If we are watching that scene, remove the old name, add the new name
		if (currentState.wtchScenes.includes(oldSceneName)) {
			currentState.wtchScenes.splice(currentState.wtchScenes.indexOf(oldSceneName), 1); // remove old name entry
			currentState.wtchScenes.unshift(sceneName); // add new one
			// Update name in pgmScns array
			if (currentState.pgmScns.includes(oldSceneName)) currentState.pgmScns[currentState.pgmScns.indexOf(oldSceneName)] = sceneName;
			// Update prvScn variable
			if (currentState.prvScn == oldSceneName) currentState.prvScn = sceneName;
			updateSceneOrInputFrontend();
			DOselectedTitleText.textContent = sceneName; // Update title text
			saveWatchParameters();
		}
	});

	// obs event InputRemoved
	obs.on("InputRemoved", async (event) => {
		const { inputName } = event;
		if (currentState.wtchInput == inputName) await getWatchSelectionItems();
	});

	// obs event InputNameChanged
	obs.on("InputNameChanged", async (event) => {
		const { oldInputName, inputName } = event;
		// If it's the input name we were watching
		if (currentState.wtchInput == oldInputName) {
			currentState.wtchInput = inputName;
			DOselectedTitleText.textContent = inputName; // Update title text
		}
	});

	// obs event SceneItemCreated
	obs.on("SceneItemCreated", async (event) => {
		const { sourceName, sceneName } = event;
		// If this scene item is of the input we are watching right now
		// .. and scene is not yet known to us
		// OR if we are watching a scene and the newly created scene item is the scene we're watching
		// ... add it to the current list of watched scenes
		if ((currentState.wtchInput == sourceName && !currentState.wtchScenes.includes(sceneName)) ||
		(currentState.watching == "Scene" && sourceName == currentState.wtchScenes[0] && !currentState.wtchScenes.includes(sceneName))) {
			currentState.wtchScenes.push(sceneName); // Add to watchlist
			updateSceneOrInputFrontend();
		}
	});

	// obs event SceneItemRemoved
	obs.on("SceneItemRemoved", async (event) => {
		const { sceneName, sourceName } = event;
		const { sceneItems } = await obs.call("GetSceneItemList", {sceneName: sceneName});
		if ((currentState.wtchInput == sourceName && !sceneItems.some(el => el.sourceName == sourceName)) ||
		((currentState.watching == "Scene" && currentState.wtchScenes[0] == sourceName && !sceneItems.some(el => el.sourceName == sourceName)))) {
			currentState.wtchScenes.splice(currentState.wtchScenes.indexOf(sceneName), 1);
			updateSceneOrInputFrontend();
			// Check if there are any scenes leftover
			if (currentState.wtchScenes.length == 0)  await getWatchSelectionItems();
		}
	});

	// Get initial status values from obs
	async function getInitialObsStates() {
		// Studio mode status
		const { studioModeEnabled } = await obs.call("GetStudioModeEnabled");
		currentState.studioModeEnabled = studioModeEnabled;

		if (currentState.studioModeEnabled) {
			// Current preview scene
			const { currentPreviewSceneName } = await obs.call("GetCurrentPreviewScene");
			currentState.prvScn = currentPreviewSceneName;
		}

		// Current program scene
		const { currentProgramSceneName } = await obs.call("GetCurrentProgramScene");
		currentState.pgmScns = [currentProgramSceneName];

		// Current streaming status
		const { outputActive: streamActive } = await obs.call("GetStreamStatus");
		currentState.StreamActive = streamActive;

		// Current recording status
		const { outputActive: recActive } = await obs.call("GetRecordStatus");
		currentState.RecActive = recActive;
	}

	function startScreenshots() {
		DOscreenshotBox.style.display = "block";
		if (!screenShotIntervalId) screenShotIntervalId = setInterval(takeObsScreenshot, screenShotInterval);
	}

	async function takeObsScreenshot() {
		if (!currentState.pgmScns[0]) return;
		const { imageData } = await obs.call("GetSourceScreenshot", {
			"sourceName": currentState.pgmScns[0],
			"imageFormat": "jpg",
			"imageWidth": screenShotSize,
			"imageCompressionQuality": 30
		});
		DOscreenshotImg.src = imageData;
	}

	function onStreamStatusChanged(status) {
		if (currentState.watching == "StreamState") {
			DOsrStatusText.textContent = status ? "LIVE" : "OFFLINE";
			document.body.style.backgroundColor = status ? "red" : "white";
		}
	} 

	function onRecordingStatusChanged(status) {
		if (currentState.watching == "RecordingState") {
			DOsrStatusText.textContent = status ? "REC" : "IDLE";
			document.body.style.backgroundColor = status ? "red" : "white";
		}
	}

	function updateSceneOrInputFrontend() {
		// Check if we care
		if (!(currentState.watching == "Scene" || currentState.watching == "Input")) return;

		// Set color depending on state
		// 2nd will overwrite first in case pgm scene was put in prv
		bgColor = "black";
		if (currentState.studioModeEnabled && currentState.wtchScenes.includes(currentState.prvScn)) {
			bgColor = "green";
		}
		if (currentState.pgmScns.some(e => currentState.wtchScenes.includes(e))) {
			bgColor = "red";
		}

		// Update page background color
		document.body.style.backgroundColor = bgColor;

		// Set text background to white in case the site background is black
		DOselectedTitleText.style.backgroundColor = (bgColor == "black") ? "white" : "transparent";
	}

	// Request data from obs and hand over to frontend creation function
	async function getWatchSelectionItems() {
		const { scenes } = await obs.call("GetSceneList");
		const { inputs } = await obs.call("GetInputList");
		const specialInputs = await obs.call("GetSpecialInputs");
		drawSelectionBoxes(scenes, inputs, specialInputs);
	}

	async function setWatchStreamStatus(event=null) {
		currentState.watching = "StreamState";
		DOselectionBox.style.display = "none";  // Hide selection div
		DOsrStatusBox.style.display = "block";  // Show status box
		DOsrStatusText.textContent = "OFFLINE";
		onStreamStatusChanged(currentState.StreamActive); // Draw initial frontend state
		saveWatchParameters(); // Save watch status to localstorage
	}

	async function setWatchRecordingStatus(event=null) {
		currentState.watching = "RecordingState";
		DOselectionBox.style.display = "none";  // Hide selection div
		DOsrStatusBox.style.display = "block";  // Show status box
		DOsrStatusText.textContent = "IDLE";
		onRecordingStatusChanged(currentState.RecActive); // Draw initial frontend state
		saveWatchParameters(); // Save watch status to localstorage
	}

	async function setWatchScene(event=null, name=null) {
		if (event) {
			var watchedScene = event.target.getAttribute("data-watchname");
		}
		if (name) {
			var watchedScene = name;
		}
		currentState.watching = "Scene";
		let watch = [watchedScene];
		// Add scenes which include the requested Scene as a source (1-level depth)
		watch = watch.concat(await getScenesFeaturingInput(watchedScene));
		currentState.wtchScenes = watch;

		// Frontend stuff
		DOselectionBox.style.display = "none"; // Hide selection div
		DOselectedTitleBox.style.display = "block"; // Show title text
		DOselectedTitleText.textContent = watchedScene; // Set title text to selected scene

		// Draw initial frontend state
		updateSceneOrInputFrontend();

		saveWatchParameters(); // Save watch status to localstorage
	}

	async function setWatchInput(event=null, name=null) {
		currentState.watching = "Input";

		if (event) currentState.wtchInput = event.target.getAttribute("data-watchname");
		if (name) currentState.wtchInput = name;

		// Frontend stuff
		DOselectionBox.style.display = "none"; // Hide selection div
		DOselectedTitleBox.style.display = "block"; // Show title text
		DOselectedTitleText.textContent = currentState.wtchInput; // Set title text to selected input

		currentState.wtchScenes = await getScenesFeaturingInput(currentState.wtchInput);

		updateSceneOrInputFrontend(); // Draw initial frontend state

		saveWatchParameters(); // Save watch status to localstorage
	}

	// Return an array of all sources that feature a specific Input
	async function getScenesFeaturingInput(Input) {
		let ftScenes = [];
		const { scenes } = await obs.call("GetSceneList");
		for (const scene in scenes) {
			let { sceneItems } = await obs.call("GetSceneItemList", {sceneName: scenes[scene].sceneName});
			if (sceneItems.some(el => el.sourceName == Input)) ftScenes.push(scenes[scene].sceneName);
		}
		return ftScenes;
	}

	async function restoreWatchStatus() {
		if (!iCanHazLocalStorage) return;
		let type = localStorage.getItem("watchSettings.type")||null;
		let name = localStorage.getItem("watchSettings.name")||null;
		switch(type) {
			case "StreamState":
				await setWatchStreamStatus();
				break;
			case "RecordingState":
				await setWatchRecordingStatus();
				break;
			case "Scene":
				await setWatchScene(null, name);
				break;
			case "Input":
				await setWatchInput(null, name);
				break;
			default:
				return;
		}
	}

	async function readLocalStorageConnectionSettings() {
		obsSettings.host = localStorage.getItem("obsSettings.host")||obsDefaultSettings.host;
		obsSettings.password = localStorage.getItem("obsSettings.password")||obsDefaultSettings.password;
	}

	async function saveLocalStorageConnectionSettings() {
		localStorage.setItem("obsSettings.host", obsSettings.host);
		localStorage.setItem("obsSettings.password", obsSettings.password);
	}

	// Save the watch parameters to localStorage
	async function saveWatchParameters() {
		if (iCanHazLocalStorage) {
			localStorage.setItem("watchSettings.type", currentState.watching);
			let name = (currentState.watching == "Input") ? currentState.wtchInput : (currentState.watching == "Scene") ? currentState.wtchScenes[0] : ""; 
			localStorage.setItem("watchSettings.name", name);
		}
	}

	// build buttons which allow user to select which scene to watch
	function drawSelectionBoxes(scenes, inputs, specialInputs) {
		// First let's clean up the frontend state
		DOselectedTitleBox.style.display = "none"; // Hide title text
		document.body.style.backgroundColor = "white"; // Cleanup background color

		// Make sure to clean all current watching state
		currentState.watching = null;

		let div = document.getElementById("selectionBox"); // Get our button holder div
		div.replaceChildren(); // Make sure the div is clean

		let headerText = document.createElement("div");
		headerText.appendChild(document.createTextNode("Select what you want to watch:"));
		div.appendChild(headerText);

		let scenesText = document.createElement("div");
		scenesText.appendChild(document.createTextNode("Scenes:"));
		let inputsText = document.createElement("div");
		inputsText.appendChild(document.createTextNode("Inputs:"));

		let ssb = document.createElement("button");
		ssb.appendChild(document.createTextNode("Stream Status"));
		ssb.addEventListener("click", setWatchStreamStatus);
		div.appendChild(ssb);

		let rsb = document.createElement("button");
		rsb.appendChild(document.createTextNode("Recording Status"));
		rsb.addEventListener("click", setWatchRecordingStatus);
		div.appendChild(rsb);

		// Selection boxes for scenes
		div.appendChild(scenesText);
		scenes.reverse().forEach(scene => {
			b = document.createElement("button");
			b.appendChild(document.createTextNode(scene.sceneName));
			b.setAttribute("data-watchName", scene.sceneName);
			b.addEventListener("click", setWatchScene);
			div.appendChild(b);
		});

		// Selection boxes for inputs
		div.appendChild(inputsText);
		specialInputs = Object.values(specialInputs);
		inputs = inputs.filter(input => !specialInputs.includes(input.inputName)); // Remove specialInputs because we can't really watch them
		inputs.forEach(input => {
			b = document.createElement("button");
			b.appendChild(document.createTextNode(input.inputName));
			b.setAttribute("data-watchName", input.inputName);
			b.addEventListener("click", setWatchInput);
			div.appendChild(b);
		});
		// Show selection div
		DOselectionBox.style.display = "block";
	}

	// Context menu stuff
	async function prepareContextMenu() {
		// Get the context menu div
		const contextMenu = document.getElementById("contextMenu");

		// Handle right clicks
		window.addEventListener("contextmenu", handleRightClick);
		async function handleRightClick(event) {
			event.preventDefault(); // Block default right click menu
			contextMenu.style.top = `${event.y}px`;
			contextMenu.style.left = `${event.x}px`;
			contextMenu.classList.add("visible");
		}

		// Handle close-(left)-clicks
		window.addEventListener("click", handleCloseClick);
		async function handleCloseClick(event) {
			if (contextMenu.classList.contains("visible")) contextMenu.classList.remove("visible");
		}

		// Handle button clicks
		contextMenu.addEventListener("click", handleMenuClick);
		async function handleMenuClick(event) {
			handler = event.target.getAttribute("data-handler");
			if (handler) contextMenuButtonClickHandlers[handler](event);
		}

		var contextMenuButtonClickHandlers = {
			"fullscreen": toggleFullscreen,
			"toggleScreenshot": async function(event) {
				if (iCanHazLocalStorage) {
					let auto = localStorage.getItem("screenshot.enable")||"No";
					if (auto == "No") {
						localStorage.setItem("screenshot.enable", "Yes");
						DOcMenableScreenshot.innerText = "Disable PGM screenshot";
						startScreenshots();
					} else {
						clearInterval(screenShotIntervalId);
						screenShotIntervalId = null;
						localStorage.setItem("screenshot.enable", "No");
						DOcMenableScreenshot.innerText = "Enable PGM screenshot";
						DOscreenshotBox.style.display = "none";
					}
				}
			},
			"toggleAutoConnect": async function(event) {
				if (iCanHazLocalStorage) {
					let auto = localStorage.getItem("connect.auto")||"No";
					if (auto == "No") {
						localStorage.setItem("connect.auto", "Yes");
						DOcMenableAutoConnect.innerText = "Disable auto connect";
					} else {
						localStorage.setItem("connect.auto", "No");
						DOcMenableAutoConnect.innerText = "Enable auto connect";
					}
				} else {
					alert("localStorage support not detected, auto connect will not work");
				}
			},
			"toggleAutoRestore": async function(event) {
				if (iCanHazLocalStorage) {
					let auto = localStorage.getItem("connect.restore")||"No";
					if (auto == "No") {
						localStorage.setItem("connect.restore", "Yes");
						DOcMenableAutoRestore.innerText = "Disable auto restore";
					} else {
						localStorage.setItem("connect.restore", "No");
						DOcMenableAutoRestore.innerText = "Enable auto restore";
					}
				} else {
					alert("localStorage support not detected, auto connect will not work");
				}
			},
			"reload": async function(event) {
				location.reload();
			},
			"clrSavedData": async function(event) {
				await clearLocalStorage();
				location.reload();
			}
		}
	}

	// Check if fullscreen is active, if not activate, deactivate
	async function toggleFullscreen() {
		if (!document.fullscreen) {
			await document.documentElement.requestFullscreen();
		} else {
			await document.exitFullscreen();
		}
	}

	async function clearLocalStorage() {
		localStorage.removeItem("obsSettings.host");
		localStorage.removeItem("obsSettings.password");
		localStorage.removeItem("watchSettings.type");
		localStorage.removeItem("watchSettings.name");
		localStorage.removeItem("connect.auto");
		localStorage.removeItem("connect.restore");
		localStorage.removeItem("screenshot.enable");
	}

	function setValue(element, value) {
		element.value = value;
	}
</script>
<style>
html {
	height: 100%;
	width: 100%;
}

body {
	height: 100%;
	width: 100%;
	overflow: hidden;
	font-family: monospace;
}

#selectionBox {
	height: 98%;
	width: auto;
	overflow-y: scroll;
	overflow-x: auto;
	padding-left: 15px;
	font-size: 1.5em;
	display: none;
}

#selectionBox button {
	font-size: 1em;
}

#settingsBox {
	margin: 20px;
}

#selectedTitleBox {
	display: none;
	text-align: center;
}

#selectedTitleText {
	font-weight: bold;
	font-size: 3em;
}

button {
	margin: 8px;
	font-size: 1.5em;
	display: block;
}

input {
	margin: 8px;
	font-size: 1.5em;
}

#srStatusBox {
	display: none;
	text-align: center;
}

#srStatusText {
	font-weight: bold;
	font-size: 24vw;
}

#screenshotBox {
	z-index: 100;
	display: none;
	position: fixed;
    bottom: 5%;
}

#screenshotImg {
	padding: auto;
	border: 5px solid black;
}

#contextMenu {
	position: fixed;
	z-index: 1000;
	width: auto;
	background: #1b1a1a;
	border-radius: 5px;
	display: none;
}

#contextMenu.visible {
	display: block;
}

#contextMenu .item {
	padding: 8px 10px;
	font-size: 20px;
	color: #eee;
	cursor: pointer;
}

#contextMenu .item:hover {
	background: #343434;
}
</style>
</head>
<body>
	<div id="contextMenu">
		<div class="item" data-handler="fullscreen">Toggle fullscreen</div>
		<div class="item" data-handler="toggleScreenshot" id="cMenableScreenshot">Enable PGM screenshot</div>
		<div class="item" data-handler="toggleAutoConnect" id="cMenableAutoConnect">Enable auto connect</div>
		<div class="item" data-handler="toggleAutoRestore" id="cMenableAutoRestore">Enable auto restore</div>
		<div class="item" data-handler="reload">Reload page</div>
		<div class="item" data-handler="clrSavedData">Clear all saved settings</div>
	</div>
	<div id="screenshotBox">
		<img id="screenshotImg" src="">
	</div>
	<div id="settingsBox">
		Host/IP + Port:<input type="text" id="obsHost" placeholder="obs host">
		Websocket Password:<input type="text" id="obsPw" placeholder="obs password">
		<button type="button" onclick="attemptObsConnection();">Connect to OBS</button>
	</div>
	<div id="selectionBox"></div>
	<div id="selectedTitleBox">
		<span id="selectedTitleText"></span>
	</div>
	<div id="srStatusBox">
		<span id="srStatusText"></span>
	</div>
</body>
